## API Report File for "@memo28/enhance-redux"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Action } from '@reduxjs/toolkit';
import { AnyAction } from '@reduxjs/toolkit';
import { ConfigureStoreOptions } from '@reduxjs/toolkit';
import { Draft } from '@reduxjs/toolkit';
import { enableConfigurationTypes } from '@memo28/open-source-tool';
import { EnhancedStore } from '@reduxjs/toolkit';
import { fn } from '@memo28/types';
import { Middleware } from '@reduxjs/toolkit';
import { PayloadActionCreator } from '@reduxjs/toolkit/src/createAction';
import { Reducer } from '@reduxjs/toolkit';
import { ReduxLoggerOptions } from 'redux-logger';
import { Slice } from '@reduxjs/toolkit';
import { SliceCaseReducers } from '@reduxjs/toolkit/src/createSlice';
import { StoreEnhancer } from '@reduxjs/toolkit';
import { ThunkMiddlewareFor } from '@reduxjs/toolkit/dist/getDefaultMiddleware';

// Warning: (ae-forgotten-export) The symbol "createActionMapperType" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class CreateAction<O extends createActionMapperType> implements createActionImpl<O> {
    actionIterator(callback?: fn<[string], void>): void;
    addAction<Obj extends object, Type extends string>(type: Type): CreateAction<O & createActionMapperType<Type, Obj>>;
    getAction<K extends keyof O>(type: K): O[K];
    getAllActions(): O;
}

// @public
export abstract class createActionImpl<O extends createActionMapperType<"", {}>> {
    abstract actionIterator(callback?: fn<[string], void>): void;
    abstract addAction<Obj extends object, Type extends string>(type: Type): createActionImpl<O & createActionMapperType<Type, Obj>>;
    abstract getAction<K extends keyof O>(type: K): O[K];
    abstract getAllActions(): O;
}

// @public
export class CreateCase<A extends createActionImpl<createActionMapperType<"", {}>>, S extends object = object> implements createCaseImpl<S, A> {
    // Warning: (ae-forgotten-export) The symbol "createCaseImplAction" needs to be exported by the entry point index.d.ts
    addCase<Type extends keyof ReturnType<A["getAllActions"]>>(type: Type, handler: fn<[state: Draft<S>, action: createCaseImplAction<A, Type>], void>): this;
    // Warning: (ae-forgotten-export) The symbol "caseCollection" needs to be exported by the entry point index.d.ts
    getCaseCollection(): Partial<caseCollection<S, A>>;
    getCaseItem<Type extends keyof ReturnType<A["getAllActions"]>>(type: Type): fn<[Draft<S>, createCaseImplAction<A, Type>], void>;
}

// @public
export abstract class createCaseImpl<S extends object, A extends createActionImpl<createActionMapperType<"", {}>>> {
    abstract addCase<Type extends keyof ReturnType<A["getAllActions"]>>(type: Type, handler: fn<[Draft<S>, createCaseImplAction<A, Type>], void>): this;
    abstract getCaseCollection(): Partial<caseCollection<S, A>>;
    abstract getCaseItem<Type extends keyof ReturnType<A["getAllActions"]>>(type: Type): fn<[Draft<S>, createCaseImplAction<A, Type>], void>;
}

// @public
export class CreateSlice<S extends object, N extends string, A extends createActionImpl<createActionMapperType> = createActionImpl<createActionMapperType>> implements createSliceImpl<S, N, A> {
    constructor(name: N, state: S, actions: A, cases?: createCaseImpl<S, A> | undefined);
    done(): Slice<S, SliceCaseReducers<S>, N>;
    // (undocumented)
    getActions(): A;
    // (undocumented)
    getSliceName(): N;
    // (undocumented)
    getState(): S;
}

// @public
export abstract class createSliceImpl<S extends object = any, N extends string = any, A extends createActionImpl<createActionMapperType> = createActionImpl<createActionMapperType>> {
    abstract done(): Slice<S, Reducer<S>, N>;
    abstract getActions(): A;
    abstract getSliceName(): N;
    abstract getState(): S;
}

// Warning: (ae-forgotten-export) The symbol "Middlewares" needs to be exported by the entry point index.d.ts
//
// @public
export class DefaultMiddleware<S = any, M extends Middlewares<S> = [ThunkMiddlewareFor<S>]> implements defaultMiddlewareImpl<S, M> {
    constructor(config?: defaultMiddlewareImplConfig);
    // (undocumented)
    getDefaultMiddleware(): M[];
}

// @public (undocumented)
export abstract class defaultMiddlewareImpl<S = any, M extends Middlewares<S> = [ThunkMiddlewareFor<S>]> {
    abstract getDefaultMiddleware(): M[];
}

// @public (undocumented)
export interface defaultMiddlewareImplConfig {
    // (undocumented)
    reduxLogger?: enableConfigurationTypes<ReduxLoggerOptions>;
    // (undocumented)
    thunk?: enableConfigurationTypes<boolean>;
}

// Warning: (ae-forgotten-export) The symbol "Enhancers" needs to be exported by the entry point index.d.ts
//
// @public
export class EnhanceRedux<S = any, A extends Action = AnyAction, M extends Middlewares<S> = [ThunkMiddlewareFor<S>], E extends Enhancers = [StoreEnhancer]> implements enhanceReduxImpl<S, A, M, E> {
    addSlice<State extends object, N extends string>(slice: createSliceImpl<State, N>): EnhanceRedux<S & State, A, M, E>;
    getStore(config?: ConfigureStoreOptions<S, A, M, E>): EnhancedStore<S, A, M, E>;
    // Warning: (ae-forgotten-export) The symbol "injectionAllocationConfig" needs to be exported by the entry point index.d.ts
    injectionAllocation(config?: injectionAllocationConfig<S, M>): this;
}

// @public (undocumented)
export interface enhanceReduxImpl<S = any, A extends Action = AnyAction, M extends Middlewares<S> = [ThunkMiddlewareFor<S>], E extends Enhancers = [StoreEnhancer]> {
    addSlice<State extends object, N extends string>(slice: createSliceImpl<State, N>): enhanceReduxImpl<S, A, M, E>;
    getStore(config?: ConfigureStoreOptions<S, A, M, E>): EnhancedStore<S, A, M, E>;
    injectionAllocation(config?: injectionAllocationConfig<S, M>): this;
}

```
