<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@memo28/types](./types.md)

## types package

常用工具类型，判断类型, 测试类型

## Interfaces

|  Interface | Description |
|  --- | --- |
|  [AutomaticAssembly](./types.automaticassembly.md) | 自动装配,通常使用在读写配置场景中 在写插件时总结出来的配置类型 |

## Type Aliases

|  Type Alias | Description |
|  --- | --- |
|  [bool](./types.bool.md) | <code>boolean</code> 别名 |
|  [Equal](./types.equal.md) | 这是一个创造性的使用条件类型的可分配行规则的解决方案. 它依赖于在未知时被延迟推导的条件类型<code>T</code> ，延迟类型条件的可分配依赖于内部 <code>isTypeIdenticalTo</code> 检查,这仅是用于 1. 两种条件类型具有相同的约束 2. 两个条件的真假分支是同一类型 |
|  [Expect](./types.expect.md) | 验证<code>true</code>类型 如果泛型参数不为 <code>true</code> 将编译不通过 |
|  [Extends](./types.extends.md) | 用于检查类型 <code>E</code> 是否继承于 类型 <code>V</code> |
|  [fn](./types.fn.md) | 定义一个普通函数 |
|  [getKeys](./types.getkeys.md) | 获取 对象 的 所有 key type |
|  [getValues](./types.getvalues.md) | 获取 对象 的 所有 <code>value</code> type |
|  [int](./types.int.md) | <code>number</code> 别名 |
|  [IsAny](./types.isany.md) | <code>0 extends 1</code> 永远返回<code>false</code>, (<code>0</code> 不可分配给 <code>1</code>), 因此<code>0 extends (1 &amp; T)</code> 也不会满足,因为 <code>( 1 &amp; T)</code> 比 <code>1</code> 的类型范围 更窄 . 但是当<code>T</code> 是 <code>any</code> 时 , 由于 <code>any</code> 是故意不健全的类型(顶级类型), 并且充当了几乎所有其他类型的超类型和子类型, 因此比较<code>any</code>时其他类型会被忽略 就变成了 <code>0 extends any</code>, 自然返回 <code>true</code>. 需要注意的时这仅仅适用 <code>strictNullChecks</code> 启用 (默认启用) |
|  [IsFalse](./types.isfalse.md) | 同 [Expect](./types.expect.md) 用法相同 不过取了个反 |
|  [mergeFnWithPromiseFn](./types.mergefnwithpromisefn.md) | 兼容普通函数和<code>promise</code>函数类型 |
|  [obj](./types.obj.md) | <code>object</code> 别名 |
|  [objWithValue](./types.objwithvalue.md) | 指定 <code>obj</code> 的 <code>value</code>类型 |
|  [promiseFn](./types.promisefn.md) | 定义一个<code>promise</code>函数 |
|  [str](./types.str.md) | <code>string</code> 别名 |
|  [SuperObject](./types.superobject.md) | 对象类型的集合方法 可直接获取到<code>keys and values</code> 未来将会有更多方法被安装到 <code>SuperObject</code> 类型上 |

